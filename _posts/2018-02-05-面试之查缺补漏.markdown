---
layout: post
title: 面试经历总结
date: 2018-08-02
tags: 面经
categories: ios
---

### get和post的区别
- get用于获取资源，post用于提交数据
- POST是一个可能有副作用的方法，但GET应是没有副作用的的；副作用--改变服务器状态
- POST和GET都不保证安全
- GET是幂等的，而POST不是
- 使用载荷的POST比使用URI的GET可以传递更多数
- GET都是可被缓存的，POST不会
### http有哪些部分
### tcp和udp的区别
- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付;Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
- TCP对系统资源要求较多，UDP对系统资源要求较少。
### 进程间的通信方式，并举例
### 两个进程分别指向同一个地址空间并初始化一个值，分别输出是什么
### Autorelease pool的实现原理
- 释放时机
AutoreleasePool App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。
- 是由AutoreleasepoolPage为节点组成的双向链表，提供push，pop的api，用于建立page、入栈待释放的对象，释放对象
### 进程和线程的区别
线程与进程的主要区别在于，系统的资源分配和管理的方式；进程是系统分配资源的独立单位；线程是CPU调度的最小单位；进程进程之间是独立的内存空间，线程之间共享进程的资源；进程有保护机制，一个进程崩溃了不会影响其他进程；进程的一个线程崩溃了，进程也会崩溃；
### 如何自己设计json转mode
### isEquel和hash的关系
调用hash的时候，应该：
Step 1: 集成成员的hash值是否和目标hash值相等, 如果相同进入Step 2, 如果不等, 直接判断不相等
Step 2: hash值相同(即Step 1)的情况下, 再进行对象判等, 作为判等的结果
默认的hash是，用对象的地址进行hash
### bitmap的结构
### 主线程是相对于什么而言的
### 一张图片的内存占用大小是由什么决定的
解压后的bitmap的大小，width * height * 4字节
### 索引的作用
### 索引的优缺点
### GCD、NSThread、NSOperator的区别
GCD: 将任务发送到队列去执行
NSThread:最轻量的线程，得自己管理线程的同步，依赖，状态等等
NSOperation：面向对象，基于GCD实现；适合复杂多任务场景的实现，便于线程管理，状态收集和管理，可以设置依赖等等，灵活性很强
### 有哪些锁
### 可变数组的实现原理
底层采用，环形缓存区的思路实现；可以满足任意一端的插入或者删除的操作有稳定的性能
### 自旋锁和互斥锁的区别
自旋锁：当给实例变量的@property设置atomic属性的时候，会给这个变量加一个自旋锁。
互斥锁：通过@synchronized来创建一个互斥锁。多线程环境下，如果访问同一个资源，那么必须使用同一把锁才能锁住

自旋锁一般用用多核的服务器。
自旋锁(Spin lock)
自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。其作用是为了解决某项资源的互斥使用。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远 高于互斥锁。虽然它的效率比互斥锁高，但是它也有些不足之处：

互斥锁
Mutex属于sleep-waiting类型的锁
### 数组copy后里面的元素会复制一份新的吗
不会
### 数组的浅拷贝与深拷贝
对于数组本身而言，不针对数组中保存的元素
### TCP为什么是三次握手和四次挥手
三次保证通信是双工的
### 如何检测应用是否卡顿
fps计算；CADisplayLink
### 程序在运行时操作系统除了分配内存空间还有什么
### MVVM