---
layout: post
title: 《高性能iOS应用开发》读书笔记
date: 2018-03-14
tags: 读书笔记
categories: ios
---
#### 性能指标
- 内存使用量
- 电量的消耗
- 应用初始化的时间
- 执行速度
- 响应速度
- 本地存储的使用；如果你的应用使用了本地存储，那么请提供一个清除数据的选项。
- 适应网络环境
- 数据刷新
- 单点登录
- 安全
- 崩溃，崩溃报告、检测和分析

#### 内存管理
- iOS中内存消耗指的是应用消耗的RAM；iOS的虚拟内存模型并不包含交换内存，与桌面应用不同，这意味这磁盘不会被用来分页，最终的结果就是应用只能使用有限的RAM。应用中的内存消耗分为两部分：栈大小和堆大小
- **栈空间**，应用中每个线程都有专用的栈空间，该空间有保留的内存和初始提交的内存组成。栈可以在线程存在期间自由的使用。线程的栈空间很小，这就决定了一下的限制
    - 可以被递归调用的最大方法数
    - 一个方法中最多可以使用的变量个数
    - 视图层级中可以嵌入的最大视图深度
- 自动释放池块（@autoreleasepool{}）是允许你放弃对一个对象的持有关系，但可以避免它立即被回收的一个工具。当从方法返回对象的时候非常有用;块中收到过autorelease消息的所有对象都会在autoreleasepool块结束的时候收到realease消息；@autoreleasepool块可以嵌套，被调用的方法可以拥有自己的@autoreleasepool，以提前执行对象的回收；
    - 在循环中需要创建很多历史的大对象用于执行某项操作，循环中可以使用@autoreleasepool块为每一次迭代释放内存，可以降低应用的最大内存的需要
    - 对于任何的自定义线程，必须创建自己的@autoreleasepool
- 当使用NSTimer和NSThread的时候，总是应该使用间接的层（任务类进行封装）实现明确呃销毁过程，这个间接层应使用弱引用，从而保证所拥有的对象能够在停止使用后执行销毁动作
- 尽量避免不必要的使用单例，无法完全避免单里的使用，但是至少可以尽量避免直接使用单例，而是采用“依赖注入”的方式使用单例
- 出现低内存告警时，应该对应用进行埋点，包括内存的使用及统计信息，并在应用重新裕兴时将这些信息上报给服务器
- 最佳实践
    - 避免大量的使用单例
    - 对子对象使用__strong
    - 对父对象使用__weak
    - 对引用图闭合的对象使用__weak
    - 对数值属性，使用assign限定符
    - 对于块属性，使用copy限定符

#### 能耗
- 应用计算越多，消耗的电量就越多。在完成相同的基本操作时，老一代的设备会消耗更多的电量。
- 蜂窝网络的电量消耗，要远大于wifi；由于蜂窝网络要定期扫描以发现网络信号更强的网络
- 将消耗带宽的非关键联网请求,缓存到队列中甚至磁盘中,观察网络状态,当网络状态处于wifi环境中才处理这些请求

#### 并发编程
- 所有的UI元素都需要在主线程中创建和管理
- 与用户交互相关的中断都会在主线程中处理，*IBAction方法的代码都会在主线程中进行*
- 线程的开销
    - 消耗约1KB的内核内存空间
    - 主线程的栈空间大小为1M，而且无法修改，所有的二级线程默认分配512KB的栈空间；*完整的栈空间并不会立即被创建出来，实际的栈空间的大小会随着使用而增长*。因此，即使主线程有1MB的栈空间，在某个时间点的实际的栈空间很可能会小很多
- GCD线程池有线程个数的上限，限制为64个如果超过个数，则会引起崩溃
- 原子属性（atomic）不一定保证代码是线程安全的
- NSCondition，用于协调线程之间的执行。*使用NSCondition可以解决标准的生产者消费者问题*
- 使用线程屏障块（dispatch_barrier_sync/dispatch_barrier_async）实现读写锁
    - 创建自定义的并发队列（DISPATCH_QUEUE_CONCURRENT）
    - 将dispatch_sync/dispatch_async用于读取操作
    - 将dispatch_barrier_sync/dispatch_barrier_async用于写操作
- 主线程的主队列（mainQuque）是串行队列，故此向在主线程中向主队列提交sync任务会造成死锁
- dispatch_sync添加任务到队列，不会创建新的线程都是在当前线程中处理的。无论添加到串行队列里或者并行队列里，都是串行效果，因为这个方法是等任务执行完成以后才会返回。
- dispatch_async添加任务到
    - mainQueue不创建线程，在主线程中串行执行
    - globalQueue 和 并行队列：根据任务系统决定开辟线程个数
    - 串行队列：创建一个线程：串行执行。
- 使用生成器对多字段（并且有可能版本迭代）的模型进行初始化，好处是可支持版本向下兼容，避免采用构造器的方式造成参数膨胀式的增长，并且便于提供默认值

#### 应用的生命周期
- 优化启动过程（缩减在didLaunch回调中在主线程执行的时间）
    - 确定在展示UI前必须执行的任务
    - 按顺序执行任务
    - 将任务拆分为必须主线程中执行的任务和可以在其他线程中执行的任务，然后分别执行
    - 其他任务在加载UI后执行或异步执行
- 